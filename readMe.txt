******************************** 设计模式 ********************************

GOF-23

1.2 工厂模式

简单工厂模式：
适用于创建对象较少，客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心！
缺点：增加新产品时需要修改工厂类的逻辑判断，违背开闭原则；工厂内产品种类不一时，违背单一职责！不易于扩展过于负责的产品结构！

工厂方法模式定义：
是指定义一个创建对象的接口，但让实现该接口的子类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行！

理解：
简单工厂模式是创建产品的工厂！工厂方法模式是创建工厂的工厂！抽象工厂模式是复杂产品的工厂！
注抽象工厂可能不符合开闭原则，例如Spring中使用抽象工厂很多！

抽象工厂模式：
是指提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的实现类！
缺点：规定了所有可能被创建的产品集合，在产品族中扩展新产品困难，需要修改抽象工厂的接口！增加了系统的抽象性和理解难度！

1.3 单例模式
是指确保一个类在任何情况下都只有一个实例，并提供一个全局访问点！
1、饿汉式单例
2、懒汉式单例
3、注册时单例
4、ThreadLocal单例


1.4 原型模式和建造者模式

原型模式：
是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建这些对象！
调用者不需要知道任何创建对象的细节，不用调用构造函数！（将创建对象的逻辑封装起来！）
属于创建型模式！

原型模式的优点：
性能好，java自带的原型模式是基于内存二进制流的拷贝，比直接new一个对象性能上提升了很多！
可以使用深克隆保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，简化了创建过程！

缺点：
需要为每一个类配置一个clone方法！
clone方法位于类内部，当对类进行改动时，违背了开闭原则！
在实现深克隆时要编写较为复杂的代码，对对象属性存在多层嵌套时，为了实现深克隆要为每一层对象对应的类都必须支持深克隆！

适用场景：
1、类初始化消耗资源过多时
2、new产生一个新对象的过程非常繁琐时（数据准备，访问权限等...）
3、构造函数复杂
4、循环体中生产大量对象

浅克隆和深克隆：
浅克隆，实现jdk中的Cloneable！克隆的是对象的引用地址！
深克隆，通过序列化或转json的方式实现！


建造者模式：
是指将一个复杂对象的构建过程和它的表示分离，使得同样的构建过程（同样的代码）可以创建不同的表示！




1.5代理模式
属于结构型模式！
是指为其他对象提供一种代理，以控制对这个对象的访问！
代理对象在客户端和目标对象之间起到中介作用！

适用场景：
1、保护目标对象
2、增强对标对象
静态代理：显式声明 被代理对象！
动态代理：运行期间创建代理对象！

动态代理配制和替换被代理对象！

jdk动态代理分析：
$开头的类都是动态代理类，只存于jvm内存中！
例如$Proxy0@407，Proxy后的0代表动态代理类的序号，表示该类是第0个生成的动态代理类！


***** jdk动态代理和Cglib动态代理：
JDKProxy对于用户而言，必须要有一个接口实现，目标类相对来说复杂！
JDKProxy生成代理的逻辑简单，执行效率相对要低，每次都要反射动态调用！

CGLib可以代理任意一个普通的类，没有任何要求！
CGLib生成代理逻辑更复杂，效率，调用效率更高，生成一个包含了所有的逻辑的FastClass，不再需要反射调用！
CGLib不能代理final的方法!

代理模式优点：
将代理对象和真实被调用的对象进行分离！降低耦合，易于扩展！
代理模式起到保护目标对象的作用！
增强目标对象的职责！

缺点：
造成系统中类增加！
在客户端和目标对象之间增加了一个代理对象，处理请求的速度变慢！
增加了系统的复杂度！

Spring中的代理选择原则：
1、当bean有实现的接口时，使用jdk动态代理！
2、当bean没有实现接口时，使用Cglib！
3、Spring可以通过配置强制使用Cglib，在容器xml中增加<aop:aspectj-autoproxy proxy-target-class="true"/>

jdk动态代理为啥必须要实现接口？
因为生成的代理类就是实现了接口，从而知道需要实现哪些需要被代理的方法！
而Cglib的生成代理类是继承，意味着子类拥有了父类所有的代码！


1.6门面模式和装饰器模式

门面模式（facade pattern）：又叫外观模式，提供了一个统一的接口，用来访问子系统中的一群接口！
特征：门面模式定义个一个高层接口，让子系统更容易使用！
属于结构型模式！

适用场景：
子系统越来越复杂，增加门面模式提供简单接口！
构建多层系统结构，利用门面对象作为每层的入口，简化层间调用！

1、门面模式与代理模式：
门面模式就是特殊的静态代理模式！区别在于，门面模式重点在于封装，静态代理重点在于增强！
所以可以理解为不做增强的静态代理就是门面模式！
（以后会有委派模式，也是一种静态代理！）
代理：结构型模式！
委派：行为型模式！不属于gof23

2、门面模式与单例模式
很多时候会把门面做成单例！例如Utils类！

门面优点：
1、简化调用过程，无需深入了解子系统，以防给子系统造成风险！
2、减少客户端依赖，松耦合！
3、更好划分层次，提高安全性！
4、遵循迪米特法则，最少知道原则！

门面缺点：
1、子系统扩展时，门面也需要修改，可能带来未知风险！
2、不符合开闭原则！
3、某些情况下违背单一职责原则！



装饰器模式（Decorator Pattern）：又叫包装模式（Wrapper Pattern），是指在不改变原有对象的基础上，将功能附加到原对象上，提供了比继承更有弹性的代替方案！（扩展原有对象的功能）
属于结构型模式！

运行期间进行功能“扩展”！（透明、动态的扩展！）

适用场景：
1、用于扩展一个类的功能或给一个类添加附加职责！
2、动态的给一个对象添加功能，这些功能可以再动态的撤销！


装饰器模式和代理模式对比：
1、装饰器模式就是一种特殊的代理模式（静态代理）！
2、装饰器模式强调自身的功能进行透明（用户自己看得到）、动态定制的扩展！
3、代理模式强调代理过程的控制！

装饰器模式优点：
1、装饰器是继承的有力补充，比继承更灵活，不改变原有对象的情况下动态的给一个对象扩展功能！
2、通过使用不同的装饰类以及这些装饰类的排列组合，可实现不同效果！
3、完全符合开闭原则！

缺点：类多，增加程序复杂性！



1.7享元模式和组合模式

享元模式（Flyweight Pattern）又称轻量级模式，是对象池的一种实现！
类似于线程池，线程池可以避免不停的创建和销毁多个对象，消耗性能！
提供了减少创建对象数量从而改善应用所需的对象结构的方式！

核心思想：共享细粒度对象，将对多个同一对象的访问集中起来！

属于结构型模式！

享元模式将一个对象的状态分成内部状态（不随环境改变）和外部状态，内部状态指不变的，外部状态是变化的！

适用场景：
常用于系统底层开发，以便解决系统性能问题！
系统有大量相似的对象，需要缓冲池的场景！

优点：
减少对象的创建，降低内存中的对象数量，降低系统的内存！
减少内存之外其他的资源占用！（如创建tcp连接数量！）

缺点：
使用时需关注内部、外部状态、线程安全！

享元模式中的享元工厂一般是和单例模式配合使用！比如连接池在整个应用只需要有一个！

组合模式（Composite Pattern）也称整体-部分模式，它的宗旨是通过将单个对象（叶子节点）和组合对象（树枝节点）用相同的接口进行表示！各节点具有相同的生命周期！

作用：是客户端对单个对象和组合对象保持一致的方式处理！

属于结构型模式！

适用场景：
1、希望客户端可以忽略组合对象和单个对象的差异时
2、对象层次具备整体和部分，呈树形结构（如树形菜单，操作系统目录结构，公司组织架构等）

优点：
1、清晰的定义分层地的复杂对象，表示对象的全部或部分层次
2、让客户端忽略了层次的差异，方面对整个层次结构进行控制
缺点：
1、限制类型时会较为复杂
2、使设计更加抽象

1.8 适配器模式和桥接模式
适配器模式（Adapter Pattern）又叫做变压器模式，他的功能是将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口匹配而导致无法在一起工作的两个类能一共使用！

属于结构型模式！

适用场景：
1、已经存在的类，它的方法和需求不匹配（方法结果相同或类似）的情况
2、适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同的产品，不同厂家造成功能类似而接口不同时的解决方案

优点：
1、提高类的透明性和复用性，现有的类复用单不需要改变
2、目标类和适配器类解耦，提高程序的扩展性
3、在很多业务场景中符合开闭原则



桥接模式（Bridge Pattern）也成为桥梁模式、接口模式（interface）或柄体模式（handler and body）模式，是将抽象部分与它的具体实现部分分离，使他们都可以独立的变化！

通过组合的方式建立两个类之间的关系，而不是通过继承！
很多情况下，桥接模式是多继承的代替方案！

属于结构型模式！

适用场景：
1、在抽象和具体实现之间需要增加更多的灵活性的场景！
2、一个类存在两个（或多个）独立变化的维度，而这两个（或多个）维度都需要进行独立的扩展！
3、不希望使用继承，或因为多层继承导致系统中类数量增加！

优点：
1、分离抽象部分和具体实现部分
2、提高了系统的扩展性
3、符合开闭原则
4、符合合成复用原则

缺点：
1、增加系统理解难度
2、需要正确识别系统中两个独立变化的维度

类似模式对比：
1、桥接模式和组合模式
2、桥接模式和适配器模式

1.9委派模式和模板方法模式

委派模式（Delegate Pattern）又叫委派模式，是负责任务的调度和任务分配，将任务的分配和执行分离开来。可以看做是一种特殊情况下的静态代理的全权代理。

不属于gof23中设计模式之一。

属于行为模式！

适用场景：
1、委派对象本身不知道如何出炉一个任务（或一个请求），把请求交给其他对象对处理！
2、实现程序的解耦！

优点：
1、通过任务委派将一个大型的任务细化，然后通过统一管理这些子任务的完成情况实现任务的跟进，加快任务的执行效率！
2、委派模式需要根据任务的复杂程度进行不同的改变，复杂情况下可能会进行多重委派，容易造成紊乱！

委派模式和代理模式区别：
1、委派是行为型模式，代理是结构性模式！
2、委派注重的是任务派遣，注重结果；代理注重的是增强，注重过程！
3、委派是一种特殊的静态代理，相当于全权代理！


委派和门面区别：
委派是全权代理，门面是中间过程的一种部分代理！
委派代理的是一类职责，门面整合的一般是多种类型的子服务！




模板方法模式（Template Method Pattern）通常又叫模板模式，是指定义一个算法的骨架，并允许子类为其中一个或者多个步骤提供实现！

模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤！

属于行为型模式！

适用场景：
1、一次性实现一个算法不变的部分，并将可变的行为留给子类来实现！
2、各子类中公共的行为被提取出来并集中到一个公共的父类中！

钩子方法：根据条件去决定是否调用！

优点：
1、利用模板方法将相同处理逻辑的代码放到抽象父类中，提高代码复用性！
2、将不同的逻辑放到不同的子类中，通过对子类的扩展增加新的行为，提高代码扩展性！
3、将不变的行为放在父类中，去重子类重复代码，提供一个良好的代码复用平台，符合开闭原则！

缺点：
1、类多
2、因使用继承，父类新增抽象方法时，需要修改所有子类！



1.10策略模式和责任链模式

策略模式（Strategy Pattern）又叫政策模式，它是将定义的算法家族，分别封装起来，让他们之间可以互相替换，从而让算法的变化不会影响到使用算法的用户！

可以避免多重分支的if else和switch语句

属于行为型模式！

适用场景：
1、假如系统有很多类，而他们的区别仅仅在于他们的行为不同！
2、一个系统中需要动态的在几种算法中选择一种！
3、需要屏蔽算法规则！

策略模式和委派模式一起使用！DispatchServlet中获取uri映射
策略模式和工厂模式一起使用，策略工厂！
策略类之间还可以继承使用！


优点：
1、策略模式符合开闭原则!
2、避免使用多重条件转移语句，如if else，switch等！
3、使用策略模式可以提高算法的保密性和安全性！

缺点：
1、客户端必须知道所有的策略，并自行决定使用哪一个类略类！
2、代码中会有很多策略类，增加维护成本！



责任链模式（Chain of Responsibility Pattern）是将链中每一个节点看做是一个对象，每个节点处理的请求均不同，且内部自动维护一个下一节点对象，当一个请求从链式的首段发出时，会沿着链的路径依次传递给每一个节点对象，直至有节点对象处理这个请求为止！

属于行为型模式！

适用场景：
1、多个对象可以处理同一请求，具体由哪个对象处理则在运行动态时决定！
2、在不明确指定接收者情况下，向多个对象中的一个提交请求！
3、可动态指定一组对象处理请求！

可以用双向链表实现chain，比如Netty中就是使用双向链表实现Pipeline（进栈出栈）！
而Filter是单向链表实现的！

优点：
1、请求和处理解耦！
2、请求处理者（节点对象）只需要关注自己感兴趣的请求进行处理，对于不感兴趣的可以交给后续节点处理！
3、具备链式传递处理请求功能，请求发送者无需知道链路结构，只需要等待请求处理结束！
4、链路结构灵活，可以通过改变链路结构动态的新增或删除责任类！
5、易于扩展，符合开闭原则！

缺点：
1、链路过长可能导致处理时间变长，影响性能！
2、如果节点对象中存在循环引用时，造成死循环系统💥！

很多权限校验框架中，大量使用责任链！Spring Security、Shiro等...

1.11 迭代器模式和命令模式

迭代器模式（Iterator Pattern）又称为游标模式（Cursor Pattern），它提供一种顺序访问集合/容器对象元素的方法，而又无需暴露集合内部表示！

核心思想：抽离集合对象迭代行为到迭代器中，提供统一访问接口！

属于行为型模式！

一般存在于框架内部，一般不需要重复去造轮子！

适用场景：
1、访问一个集合对象内容时无需暴露它的内部表示！
2、为遍历不同的集合数据结构提供一个统一的访问接口！

迭代器模式优点：
1、多态迭代：为不同的聚合结构（不同类型集合）提供了一致的遍历接口，即一个迭代接口可以访问不同的聚合结构！
2、简化集合对象接口：迭代器模式将集合对象本身应该提供元素迭代接口提取到了迭代器中，使集合元素无需关心具体迭代行为！
3、元素迭代功能多样化：每个集合对象都可以提供一个或多个不同的迭代器，使得同种元素聚合结构可以有不同的迭代行为！
4、解耦了迭代功能和集合元素：迭代器模式封装了具体的迭代算法，不会影响到集合对象的架构！

缺点：
1、对于数据结构简单的遍历（数组或有序列表），使用迭代器比较繁琐，有点小题大做！


命令模式（Command Pattern）是对命令的封装，每一个命令都是一个操作：请求方发出一个请求要求执行一个操作，接收方收到请求并执行操作。命令模式解耦了请求方和接收方，请求方只需要请求执行命令，而无需关注命令如何被接受及如何被处理！

本质：解耦命令的请求和处理！

属于行为型模式！

适用场景：
1、现实语义中具备“命令”的操作（如命令菜单，shell命令...）
2、请求调用者和请求处理者需要解耦，使得调用者和接受者不直接交互！
3、需要抽象出等待执行的行为时，比如撤销（Undo）操作和恢复（Redo）等操作！
4、需要支持命令宏时（即命令组合操作）！


优点：
1、通过引入中间件（抽象interface），解耦了命令请求和实现！
2、扩展性良好，可以容易地增加新命令！
3、支持组合命令，支持命令队列！
4、可以在现有命令的基础上，增加额外功能（比如日志记录，或结合装饰器模式使用）！

缺点：具体的命令类可能很多！



1.12状态模式和备忘录模式

状态模式（State Pattern）也称为状态机模式（State Machine Pattern），是允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类！

一个类在不同状态下有不同的行为！
将状态和行为进行绑定！

属于行为型模式！

适用场景：
1、行为随状态改变而改变！
2、一个操作中含有庞大的多分支结构，并且这些分支取决去对象的状态！


和状态模式相关的设计模式：
1、状态模式和责任链模式，都能消除if过多的问题，状态模式强调的内部状态的改变，责任链强调的是外部节点对责任之间的改变。
状态模式内部流转逻辑会预先设置好！

2、状态模式和策略模式，策略模式是多种算法选择一种，各种算法是独立的，用户可以自己确定算法；而状态模式下用户无法修改状态，状态是和行为绑定的。

优点：
1、结构清晰，将状态独立为类，消除冗余的ifelse或switch！
2、将状态转为显示化，通常对象的状态用数值类型来表示，而是用状态模式后用类表示，装换目的更加明确！
3、状态职责明确更具备扩展性！

缺点：
1、类多，复杂！
2、对于可以切换状态的状态模式，当增肌新状态时，可能会修改转换状态的代码，对开闭原则支持不佳！


备忘录模式（Memento Pattern）又称为快照模式（Snapshot Pattern）或者令牌模式（Token Pattern），是指在不破坏封装的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将该对象恢复为原状态！

特征：后悔药！

属于行为型模式！

优点：
1、简化了发起人实体类（Originator）职责，隔离状态的存储和获取，实现了信息的封装，客户端无需关心状态的保存细节！
2、提供回滚功能！

缺点：
1、当状态过多时消耗资源！

1.13中介者模式和解释器模式

中介者模式（Mediator Pattern）又称为调节者模式或调停者模式。用一个中介对象封装一系列的对象交互，中介者是使各对象不需要显式的相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互！

核心：通过中介者解耦系统各层次对象的直接耦合，层次对象的对外依赖统统交由中介者转发！

属于行为型模式！

适用场景：
1、系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解！
2、交互的公共行为，如果需要改变行为则可以增加新的中介者类！

注册中心等就是中介者思想！


中介者模式和代理模式区别：
1、都是中间角色，牵桥搭线！
2、为什么要用代理？因为委托者做不到，又必须要做！
3、中介者，只需要他给你联系上，就不管了。后续的事全权由委托者自己完成！

优点：
1、减少类间依赖，将多对多依赖转化为了一对多，降低耦合！
2、类间各司其职，符合迪米尔法则！

缺点：
中介者模式将原本多个对象直接的互相依赖变成了中介者和多个同事类的依赖关系，当同事类过多时，中介者就会越臃肿，复杂，难以维护！


解释器模式（Interpreter Pattern）给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器用来表示语言中的句子！

特征：为了解释一种语言，而为语言创建的解释器！

如编译器的作用！

属于行为型模式！

适用场景：
1、一些重复出现的问题可以用一种简单的语言来进行表示！
2、一个简单语法需要解释的场景！



1.14观察者模式和访问者模式

观察者模式（Observer Pattern）
又叫发布-订阅模式（Publish-Subscrible）、
模型-视图模式、
源-监听器模式、
从属者模式！
定义一种一对多的依赖关系，一个主题对象可以被多个观察者对象监听，使得每当主题对象状态变化时，所有依赖它的的对象都会得到通知并被自动更新！

属于行为型模式！


适用场景：
1、当一个抽象模型包含两个方面的内容，其中一个方面依赖于另一个方面！
2、一个或多个对象的变化依赖于另一个对象的变化！
3、实现类似广播机制的功能，无需知道具体的收听者们，只需分发广播，系统中感兴趣的对象对自动接收该广播!
4、多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知！


优点：
1、观察者和被观察者松耦合，符合依赖倒置！
2、分离了表示层（观察者）和数据逻辑层（被观察者），并建立了一套触发机制（回调），使得数据的变化客可以响应到多个表示层上！
3、实现了一对多的通讯机制，支持时间注册机制，支持兴趣分发机制。当被观察者触发事件时，只有感兴趣的观察者可以接收到通知！

缺点：
1、如果观察者数量过多，则事件通知会耗时较长！
2、如果事件通知呈线性关系，如果其中一个观察者事件处理卡壳，会影响后续观察者接受事件！
3、如果观察者和被观察者之间存在循环依赖，则可能造成两者之间循环调用，导致系统崩溃！


访问者模式（Visitor Pattern）是一种将数据结构和数据操作分离的设计模式！是指封装一些作用于数据结构中各元素的操作！

特征：
可以在不改变数据结构的前提下定义作用于这些元素的新的操作！

属于行为型模式！

最复杂的设计模式，但使用频率不高!


适用场景：
1、数据结构稳定，作用于数据结构的操作经常变化的场景！
2、需要数据结构和数据操作分离的场景！
3、需要对不同数据类型（元素）进行操作，而不使用分支判断具体类型的场景！


优点：
1、解耦了数据结构和数据操作，使得操作集合可以独立变化！
2、扩展性好！可以通过扩展访问者角色，实现对数据集的不同操作！
3、元素具体类型并非单一，访问者均可访问！
4、各角色职责分离，符合单一职责！

缺点：
1、无法增加元素类型，如果系统数据结构变化，则访问者也必须增加对应元素的操作，违背了开闭原则！
2、具体元素变更困难！具体元素增加属性、删除属性时会导致访问者类也进行对象修改，当有大量访问者类时，修改范围大！
3、违背了依赖倒置原则！为了达到“区别对待”，访问者依赖的是具体元素类型，而不是抽象！


*********************************************
各设计模式对比！

1、代理和中介者
代理职责是增强，不仅建立联系，还要参与过程！
中介只负责牵线搭桥，建立联系！

2、委派和代理
委派，全权的静态代理，不作任何增强！
代理，增强！
没有任何增强的代理就是委派！

3、命令和策略
命令，解耦请求和处理，会有一个回调，会有反馈和处理结果！
策略，固定好的选项，一定是同样的结果，一定要有用户参与！

4、代理和装饰器
代理，使用组合实现功能增强和扩展！
装饰，继承实现增强和扩展！

5、委派和责任链
委派，没有流程的概念，关注分发！
责任链，处理流程并且可扩展，可定制，最终结果由链中某些Handler来决定！

6、工厂方法和抽象工厂
工厂方法，注重产品本身的扩展！单向维度！
抽象工厂，产品等级和产品族的相互扩展关系，多维度，至少是二维！

7、桥接和适配器
桥接，不用继承建立关系！
适配器，类适配器是继承、对象适配器是组合、接口适配器是继承！

8、行为型和结构型
行为型，对方法的使用提出的建议！
结构型，对类的组合提出的建议！
创建型，对创建对象提出的建议！

9、抽象工厂和模板方法
抽象工厂，形式上可能会出现抽象方法，但不能体现流程！
模板方法，也有抽象方法，但一定是该流程中的某一步骤！
严格来说这俩没有可比性！

10、建造者和装饰器
建造者，强调对象创建步骤的个性化！
装饰器，强调扩展性，大桶套小桶！

11、适配器和中介者
适配器，解决兼容问题！可以用继承，也可以用组合！
中介者，一定是用组合！所有人可能都持有中介者的引用！

12、桥接和中介者
共同点，不用继承，都是用组合！
桥接，两个维度建立连接！
中介者，多维度建立连接！是一种更复杂的桥接模式的实现！

13、桥接和组合
桥接，两个继承体系建立连接！
组合，目的不是为了建立连接，而是为了统一行动，统一一套API！

14、门面和装饰器
门面，统一入口！承担一定的静态代理作用！
装饰器，为了扩展！

15、工厂模式和策略模式
一般来说，会组合使用，策略由工厂创建出来！

16、享元模式和饿汉式单例
可以把对象池的容器设置为单例，同时，把对象池所在类设置为单例的工厂！

17、桥接和命令
桥接，需要一个中间的类，该类一定是有功能实现的！
命令，需要一个抽象的中间类，该类出现只是为了规范！

18、委派和门面
门面，里面可能会用到委派模式实现任务分发！

19、策略和模板方法
有时会混合使用，模板方法中可能设计的钩子方法，就是某一个策略的实现！

*********************************************



设计模式小点：
1、模板方法是用继承实现
2、桥接模式除了用继承，用啥都行
3、装饰器模式：继承+组合（同宗同源）
4、动态代理：cglib使用继承实现的，jdk是使用组合模式实现的


比较容易混淆的有代理模式、桥接模式、门面模式、命令模式

门面模式/中介者模式：
1.门面模式是结构型模式，中介者模式是行为型模式。
2.门面模式是对子系统提供统一的接口，中介者模式是用一个中介对象来封装一系列同事对象的交互行为。
3.门面模式协议是单向，中介者模式协议是双向。
4.门面模式所有的请求处理都委托给子系统完成，而中介者模式则由中心协调同事类和中心本身共同完成业务。

代理模式/中介者模式
1.代理模式是一对一，一个代理只能代表一个对象。中介者模式则是多对多，中介者的功能多样，客户也可以多个。
2.只能代理一方。如果P是A的代理，那么C可以通过B访问A，但是A不能通过P访问B。对于中介者模式而言，A可以通过中介P访问B，B也可以通过中介P访问A。

桥接模式/中介者模式
一对多的关系，一个类可以有很多其他属性；
桥接强调不是对象之间的通信，而是拥有某些属性

命令模式/中介者模式
1.中介者模式一般接口是固定的（即请求比较固定）
2.命令模式请求一般不固定，可能会改变，所以将命令进行对象化和独立化使得代码更加灵活

访问者模式，只访问数据结构，不改变数据结构！
1、对原始数据只访问，不修改
2、大部分情况下，用于数据报表和统计
3、不同的访问者，得到不同的结果
******************************** 设计模式 ********************************

GOF-23

1.2 工厂模式

简单工厂模式：
适用于创建对象较少，客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心！
缺点：增加新产品时需要修改工厂类的逻辑判断，违背开闭原则；工厂内产品种类不一时，违背单一职责！不易于扩展过于负责的产品结构！

工厂方法模式定义：
是指定义一个创建对象的接口，但让实现该接口的子类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行！

理解：
简单工厂模式是创建产品的工厂！工厂方法模式是创建工厂的工厂！抽象工厂模式是复杂产品的工厂！
注抽象工厂可能不符合开闭原则，例如Spring中使用抽象工厂很多！

抽象工厂模式：
是指提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的实现类！
缺点：规定了所有可能被创建的产品集合，在产品族中扩展新产品困难，需要修改抽象工厂的接口！增加了系统的抽象性和理解难度！

1.3 单例模式
是指确保一个类在任何情况下都只有一个实例，并提供一个全局访问点！
1、饿汉式单例
2、懒汉式单例
3、注册时单例
4、ThreadLocal单例


1.4 原型模式和建造者模式

原型模式：
是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建这些对象！
调用者不需要知道任何创建对象的细节，不用调用构造函数！（将创建对象的逻辑封装起来！）
属于创建型模式！

原型模式的优点：
性能好，java自带的原型模式是基于内存二进制流的拷贝，比直接new一个对象性能上提升了很多！
可以使用深克隆保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，简化了创建过程！

缺点：
需要为每一个类配置一个clone方法！
clone方法位于类内部，当对类进行改动时，违背了开闭原则！
在实现深克隆时要编写较为复杂的代码，对对象属性存在多层嵌套时，为了实现深克隆要为每一层对象对应的类都必须支持深克隆！

适用场景：
1、类初始化消耗资源过多时
2、new产生一个新对象的过程非常繁琐时（数据准备，访问权限等...）
3、构造函数复杂
4、循环体中生产大量对象

浅克隆和深克隆：
浅克隆，实现jdk中的Cloneable！克隆的是对象的引用地址！
深克隆，通过序列化或转json的方式实现！


建造者模式：
是指将一个复杂对象的构建过程和它的表示分离，使得同样的构建过程（同样的代码）可以创建不同的表示！




1.5代理模式
属于结构型模式！
是指为其他对象提供一种代理，以控制对这个对象的访问！
代理对象在客户端和目标对象之间起到中介作用！

适用场景：
1、保护目标对象
2、增强对标对象
静态代理：显式声明 被代理对象！
动态代理：运行期间创建代理对象！

动态代理配制和替换被代理对象！

jdk动态代理分析：
$开头的类都是动态代理类，只存于jvm内存中！
例如$Proxy0@407，Proxy后的0代表动态代理类的序号，表示该类是第0个生成的动态代理类！


***** jdk动态代理和Cglib动态代理：
JDKProxy对于用户而言，必须要有一个接口实现，目标类相对来说复杂！
JDKProxy生成代理的逻辑简单，执行效率相对要低，每次都要反射动态调用！

CGLib可以代理任意一个普通的类，没有任何要求！
CGLib生成代理逻辑更复杂，效率，调用效率更高，生成一个包含了所有的逻辑的FastClass，不再需要反射调用！
CGLib不能代理final的方法!

代理模式优点：
将代理对象和真实被调用的对象进行分离！降低耦合，易于扩展！
代理模式起到保护目标对象的作用！
增强目标对象的职责！

缺点：
造成系统中类增加！
在客户端和目标对象之间增加了一个代理对象，处理请求的速度变慢！
增加了系统的复杂度！

Spring中的代理选择原则：
1、当bean有实现的接口时，使用jdk动态代理！
2、当bean没有实现接口时，使用Cglib！
3、Spring可以通过配置强制使用Cglib，在容器xml中增加<aop:aspectj-autoproxy proxy-target-class="true"/>

jdk动态代理为啥必须要实现接口？
因为生成的代理类就是实现了接口，从而知道需要实现哪些需要被代理的方法！
而Cglib的生成代理类是继承，意味着子类拥有了父类所有的代码！


1.6门面模式和装饰器模式

门面模式（facade pattern）：又叫外观模式，提供了一个统一的接口，用来访问子系统中的一群接口！
特征：门面模式定义个一个高层接口，让子系统更容易使用！
属于结构型模式！

适用场景：
子系统越来越复杂，增加门面模式提供简单接口！
构建多层系统结构，利用门面对象作为每层的入口，简化层间调用！

1、门面模式与代理模式：
门面模式就是特殊的静态代理模式！区别在于，门面模式重点在于封装，静态代理重点在于增强！
所以可以理解为不做增强的静态代理就是门面模式！
（以后会有委派模式，也是一种静态代理！）
代理：结构型模式！
委派：行为型模式！不属于gof23

2、门面模式与单例模式
很多时候会把门面做成单例！例如Utils类！

门面优点：
1、简化调用过程，无需深入了解子系统，以防给子系统造成风险！
2、减少客户端依赖，松耦合！
3、更好划分层次，提高安全性！
4、遵循迪米特法则，最少知道原则！

门面缺点：
1、子系统扩展时，门面也需要修改，可能带来未知风险！
2、不符合开闭原则！
3、某些情况下违背单一职责原则！



装饰器模式（Decorator Pattern）：又叫包装模式（Wrapper Pattern），是指在不改变原有对象的基础上，将功能附加到原对象上，提供了比继承更有弹性的代替方案！（扩展原有对象的功能）
属于结构型模式！

运行期间进行功能“扩展”！（透明、动态的扩展！）

适用场景：
1、用于扩展一个类的功能或给一个类添加附加职责！
2、动态的给一个对象添加功能，这些功能可以再动态的撤销！


装饰器模式和代理模式对比：
1、装饰器模式就是一种特殊的代理模式（静态代理）！
2、装饰器模式强调自身的功能进行透明（用户自己看得到）、动态定制的扩展！
3、代理模式强调代理过程的控制！

装饰器模式优点：
1、装饰器是继承的有力补充，比继承更灵活，不改变原有对象的情况下动态的给一个对象扩展功能！
2、通过使用不同的装饰类以及这些装饰类的排列组合，可实现不同效果！
3、完全符合开闭原则！

缺点：类多，增加程序复杂性！



1.7享元模式和组合模式

享元模式（Flyweight Pattern）又称轻量级模式，是对象池的一种实现！
类似于线程池，线程池可以避免不停的创建和销毁多个对象，消耗性能！
提供了减少创建对象数量从而改善应用所需的对象结构的方式！

核心思想：共享细粒度对象，将对多个同一对象的访问集中起来！

属于结构型模式！

享元模式将一个对象的状态分成内部状态（不随环境改变）和外部状态，内部状态指不变的，外部状态是变化的！

适用场景：
常用于系统底层开发，以便解决系统性能问题！
系统有大量相似的对象，需要缓冲池的场景！

优点：
减少对象的创建，降低内存中的对象数量，降低系统的内存！
减少内存之外其他的资源占用！（如创建tcp连接数量！）

缺点：
使用时需关注内部、外部状态、线程安全！

享元模式中的享元工厂一般是和单例模式配合使用！比如连接池在整个应用只需要有一个！

组合模式（Composite Pattern）也称整体-部分模式，它的宗旨是通过将单个对象（叶子节点）和组合对象（树枝节点）用相同的接口进行表示！各节点具有相同的生命周期！

作用：是客户端对单个对象和组合对象保持一致的方式处理！

属于结构型模式！

适用场景：
1、希望客户端可以忽略组合对象和单个对象的差异时
2、对象层次具备整体和部分，呈树形结构（如树形菜单，操作系统目录结构，公司组织架构等）

优点：
1、清晰的定义分层地的复杂对象，表示对象的全部或部分层次
2、让客户端忽略了层次的差异，方面对整个层次结构进行控制
缺点：
1、限制类型时会较为复杂
2、使设计更加抽象

1.8 适配器模式和桥接模式
适配器模式（Adapter Pattern）又叫做变压器模式，他的功能是将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口匹配而导致无法在一起工作的两个类能一共使用！

属于结构型模式！

适用场景：
1、已经存在的类，它的方法和需求不匹配（方法结果相同或类似）的情况
2、适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同的产品，不同厂家造成功能类似而接口不同时的解决方案

优点：
1、提高类的透明性和复用性，现有的类复用单不需要改变
2、目标类和适配器类解耦，提高程序的扩展性
3、在很多业务场景中符合开闭原则



桥接模式（Bridge Pattern）也成为桥梁模式、接口模式（interface）或柄体模式（handler and body）模式，是将抽象部分与它的具体实现部分分离，使他们都可以独立的变化！

通过组合的方式建立两个类之间的关系，而不是通过继承！
很多情况下，桥接模式是多继承的代替方案！

属于结构型模式！

适用场景：
1、在抽象和具体实现之间需要增加更多的灵活性的场景！
2、一个类存在两个（或多个）独立变化的维度，而这两个（或多个）维度都需要进行独立的扩展！
3、不希望使用继承，或因为多层继承导致系统中类数量增加！

优点：
1、分离抽象部分和具体实现部分
2、提高了系统的扩展性
3、符合开闭原则
4、符合合成复用原则

缺点：
1、增加系统理解难度
2、需要正确识别系统中两个独立变化的维度

类似模式对比：
1、桥接模式和组合模式
2、桥接模式和适配器模式

1.9委派模式和模板方法模式

委派模式（Delegate Pattern）又叫委派模式，是负责任务的调度和任务分配，将任务的分配和执行分离开来。可以看做是一种特殊情况下的静态代理的全权代理。

不属于gof23中设计模式之一。

属于行为模式！

适用场景：
1、委派对象本身不知道如何出炉一个任务（或一个请求），把请求交给其他对象对处理！
2、实现程序的解耦！

优点：
1、通过任务委派将一个大型的任务细化，然后通过统一管理这些子任务的完成情况实现任务的跟进，加快任务的执行效率！
2、委派模式需要根据任务的复杂程度进行不同的改变，复杂情况下可能会进行多重委派，容易造成紊乱！

委派模式和代理模式区别：
1、委派是行为型模式，代理是结构性模式！
2、委派注重的是任务派遣，注重结果；代理注重的是增强，注重过程！
3、委派是一种特殊的静态代理，相当于全权代理！


委派和门面区别：
委派是全权代理，门面是中间过程的一种部分代理！
委派代理的是一类职责，门面整合的一般是多种类型的子服务！




模板方法模式（Template Method Pattern）通常又叫模板模式，是指定义一个算法的骨架，并允许子类为其中一个或者多个步骤提供实现！

模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤！

属于行为型模式！

适用场景：
1、一次性实现一个算法不变的部分，并将可变的行为留给子类来实现！
2、各子类中公共的行为被提取出来并集中到一个公共的父类中！

钩子方法：根据条件去决定是否调用！

优点：
1、利用模板方法将相同处理逻辑的代码放到抽象父类中，提高代码复用性！
2、将不同的逻辑放到不同的子类中，通过对子类的扩展增加新的行为，提高代码扩展性！
3、将不变的行为放在父类中，去重子类重复代码，提供一个良好的代码复用平台，符合开闭原则！

缺点：
1、类多
2、因使用继承，父类新增抽象方法时，需要修改所有子类！



1.10策略模式和责任链模式

策略模式（Strategy Pattern）又叫政策模式，它是将定义的算法家族，分别封装起来，让他们之间可以互相替换，从而让算法的变化不会影响到使用算法的用户！

可以避免多重分支的if else和switch语句

属于行为型模式！

适用场景：
1、假如系统有很多类，而他们的区别仅仅在于他们的行为不同！
2、一个系统中需要动态的在几种算法中选择一种！
3、需要屏蔽算法规则！

策略模式和委派模式一起使用！DispatchServlet中获取uri映射
策略模式和工厂模式一起使用，策略工厂！
策略类之间还可以继承使用！


优点：
1、策略模式符合开闭原则!
2、避免使用多重条件转移语句，如if else，switch等！
3、使用策略模式可以提高算法的保密性和安全性！

缺点：
1、客户端必须知道所有的策略，并自行决定使用哪一个类略类！
2、代码中会有很多策略类，增加维护成本！



责任链模式（Chain of Responsibility Pattern）是将链中每一个节点看做是一个对象，每个节点处理的请求均不同，且内部自动维护一个下一节点对象，当一个请求从链式的首段发出时，会沿着链的路径依次传递给每一个节点对象，直至有节点对象处理这个请求为止！

属于行为型模式！

适用场景：
1、多个对象可以处理同一请求，具体由哪个对象处理则在运行动态时决定！
2、在不明确指定接收者情况下，向多个对象中的一个提交请求！
3、可动态指定一组对象处理请求！

可以用双向链表实现chain，比如Netty中就是使用双向链表实现Pipeline（进栈出栈）！
而Filter是单向链表实现的！

优点：
1、请求和处理解耦！
2、请求处理者（节点对象）只需要关注自己感兴趣的请求进行处理，对于不感兴趣的可以交给后续节点处理！
3、具备链式传递处理请求功能，请求发送者无需知道链路结构，只需要等待请求处理结束！
4、链路结构灵活，可以通过改变链路结构动态的新增或删除责任类！
5、易于扩展，符合开闭原则！

缺点：
1、链路过长可能导致处理时间变长，影响性能！
2、如果节点对象中存在循环引用时，造成死循环系统💥！

很多权限校验框架中，大量使用责任链！Spring Security、Shiro等...

1.11 迭代器模式和命令模式

迭代器模式（Iterator Pattern）又称为游标模式（Cursor Pattern），它提供一种顺序访问集合/容器对象元素的方法，而又无需暴露集合内部表示！

核心思想：抽离集合对象迭代行为到迭代器中，提供统一访问接口！

属于行为型模式！

一般存在于框架内部，一般不需要重复去造轮子！

适用场景：
1、访问一个集合对象内容时无需暴露它的内部表示！
2、为遍历不同的集合数据结构提供一个统一的访问接口！

迭代器模式优点：
1、多态迭代：为不同的聚合结构（不同类型集合）提供了一致的遍历接口，即一个迭代接口可以访问不同的聚合结构！
2、简化集合对象接口：迭代器模式将集合对象本身应该提供元素迭代接口提取到了迭代器中，使集合元素无需关心具体迭代行为！
3、元素迭代功能多样化：每个集合对象都可以提供一个或多个不同的迭代器，使得同种元素聚合结构可以有不同的迭代行为！
4、解耦了迭代功能和集合元素：迭代器模式封装了具体的迭代算法，不会影响到集合对象的架构！

缺点：
1、对于数据结构简单的遍历（数组或有序列表），使用迭代器比较繁琐，有点小题大做！


命令模式（Command Pattern）是对命令的封装，每一个命令都是一个操作：请求方发出一个请求要求执行一个操作，接收方收到请求并执行操作。命令模式解耦了请求方和接收方，请求方只需要请求执行命令，而无需关注命令如何被接受及如何被处理！

本质：解耦命令的请求和处理！

属于行为型模式！

适用场景：
1、现实语义中具备“命令”的操作（如命令菜单，shell命令...）
2、请求调用者和请求处理者需要解耦，使得调用者和接受者不直接交互！
3、需要抽象出等待执行的行为时，比如撤销（Undo）操作和恢复（Redo）等操作！
4、需要支持命令宏时（即命令组合操作）！


优点：
1、通过引入中间件（抽象interface），解耦了命令请求和实现！
2、扩展性良好，可以容易地增加新命令！
3、支持组合命令，支持命令队列！
4、可以在现有命令的基础上，增加额外功能（比如日志记录，或结合装饰器模式使用）！

缺点：具体的命令类可能很多！



1.12状态模式和备忘录模式

状态模式（State Pattern）也称为状态机模式（State Machine Pattern），是允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类！

一个类在不同状态下有不同的行为！
将状态和行为进行绑定！

属于行为型模式！

适用场景：
1、行为随状态改变而改变！
2、一个操作中含有庞大的多分支结构，并且这些分支取决去对象的状态！


和状态模式相关的设计模式：
1、状态模式和责任链模式，都能消除if过多的问题，状态模式强调的内部状态的改变，责任链强调的是外部节点对责任之间的改变。
状态模式内部流转逻辑会预先设置好！

2、状态模式和策略模式，策略模式是多种算法选择一种，各种算法是独立的，用户可以自己确定算法；而状态模式下用户无法修改状态，状态是和行为绑定的。

优点：
1、结构清晰，将状态独立为类，消除冗余的ifelse或switch！
2、将状态转为显示化，通常对象的状态用数值类型来表示，而是用状态模式后用类表示，装换目的更加明确！
3、状态职责明确更具备扩展性！

缺点：
1、类多，复杂！
2、对于可以切换状态的状态模式，当增肌新状态时，可能会修改转换状态的代码，对开闭原则支持不佳！


备忘录模式（Memento Pattern）又称为快照模式（Snapshot Pattern）或者令牌模式（Token Pattern），是指在不破坏封装的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将该对象恢复为原状态！

特征：后悔药！

属于行为型模式！

优点：
1、简化了发起人实体类（Originator）职责，隔离状态的存储和获取，实现了信息的封装，客户端无需关心状态的保存细节！
2、提供回滚功能！

缺点：
1、当状态过多时消耗资源！

1.13中介者模式和解释器模式

中介者模式（Mediator Pattern）又称为调节者模式或调停者模式。用一个中介对象封装一系列的对象交互，中介者是使各对象不需要显式的相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互！

核心：通过中介者解耦系统各层次对象的直接耦合，层次对象的对外依赖统统交由中介者转发！

属于行为型模式！

适用场景：
1、系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解！
2、交互的公共行为，如果需要改变行为则可以增加新的中介者类！

注册中心等就是中介者思想！


中介者模式和代理模式区别：
1、都是中间角色，牵桥搭线！
2、为什么要用代理？因为委托者做不到，又必须要做！
3、中介者，只需要他给你联系上，就不管了。后续的事全权由委托者自己完成！

优点：
1、减少类间依赖，将多对多依赖转化为了一对多，降低耦合！
2、类间各司其职，符合迪米尔法则！

缺点：
中介者模式将原本多个对象直接的互相依赖变成了中介者和多个同事类的依赖关系，当同事类过多时，中介者就会越臃肿，复杂，难以维护！


解释器模式（Interpreter Pattern）给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器用来表示语言中的句子！

特征：为了解释一种语言，而为语言创建的解释器！

如编译器的作用！

属于行为型模式！

适用场景：
1、一些重复出现的问题可以用一种简单的语言来进行表示！
2、一个简单语法需要解释的场景！



























设计模式小点：
1、模板方法是用继承实现
2、桥接模式除了用继承，用啥都行
3、装饰器模式：继承+组合（同宗同源）
4、动态代理：cglib使用继承实现的，jdk是使用组合模式实现的
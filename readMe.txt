******************************** 设计模式 ********************************

GOF-23

1.2 工厂模式

简单工厂模式：
适用于创建对象较少，客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心！
缺点：增加新产品时需要修改工厂类的逻辑判断，违背开闭原则；工厂内产品种类不一时，违背单一职责！不易于扩展过于负责的产品结构！

工厂方法模式定义：
是指定义一个创建对象的接口，但让实现该接口的子类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行！

理解：
简单工厂模式是创建产品的工厂！工厂方法模式是创建工厂的工厂！抽象工厂模式是复杂产品的工厂！
注抽象工厂可能不符合开闭原则，例如Spring中使用抽象工厂很多！

抽象工厂模式：
是指提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的实现类！
缺点：规定了所有可能被创建的产品集合，在产品族中扩展新产品困难，需要修改抽象工厂的接口！增加了系统的抽象性和理解难度！

1.3 单例模式
是指确保一个类在任何情况下都只有一个实例，并提供一个全局访问点！
1、饿汉式单例
2、懒汉式单例
3、注册时单例
4、ThreadLocal单例


1.4 原型模式和建造者模式

原型模式：
是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建这些对象！
调用者不需要知道任何创建对象的细节，不用调用构造函数！（将创建对象的逻辑封装起来！）
属于创建型模式！

原型模式的优点：
性能好，java自带的原型模式是基于内存二进制流的拷贝，比直接new一个对象性能上提升了很多！
可以使用深克隆保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，简化了创建过程！

缺点：
需要为每一个类配置一个clone方法！
clone方法位于类内部，当对类进行改动时，违背了开闭原则！
在实现深克隆时要编写较为复杂的代码，对对象属性存在多层嵌套时，为了实现深克隆要为每一层对象对应的类都必须支持深克隆！

适用场景：
1、类初始化消耗资源过多时
2、new产生一个新对象的过程非常繁琐时（数据准备，访问权限等...）
3、构造函数复杂
4、循环体中生产大量对象

浅克隆和深克隆：
浅克隆，实现jdk中的Cloneable！克隆的是对象的引用地址！
深克隆，通过序列化或转json的方式实现！


建造者模式：
是指将一个复杂对象的构建过程和它的表示分离，使得同样的构建过程（同样的代码）可以创建不同的表示！




1.5代理模式
属于结构型模式！
是指为其他对象提供一种代理，以控制对这个对象的访问！
代理对象在客户端和目标对象之间起到中介作用！

适用场景：
1、保护目标对象
2、增强对标对象
静态代理：显式声明 被代理对象！
动态代理：运行期间创建代理对象！

动态代理配制和替换被代理对象！

jdk动态代理分析：
$开头的类都是动态代理类，只存于jvm内存中！
例如$Proxy0@407，Proxy后的0代表动态代理类的序号，表示该类是第0个生成的动态代理类！


***** jdk动态代理和Cglib动态代理：
JDKProxy对于用户而言，必须要有一个接口实现，目标类相对来说复杂！
JDKProxy生成代理的逻辑简单，执行效率相对要低，每次都要反射动态调用！

CGLib可以代理任意一个普通的类，没有任何要求！
CGLib生成代理逻辑更复杂，效率，调用效率更高，生成一个包含了所有的逻辑的FastClass，不再需要反射调用！
CGLib不能代理final的方法!

代理模式优点：
将代理对象和真实被调用的对象进行分离！降低耦合，易于扩展！
代理模式起到保护目标对象的作用！
增强目标对象的职责！

缺点：
造成系统中类增加！
在客户端和目标对象之间增加了一个代理对象，处理请求的速度变慢！
增加了系统的复杂度！

Spring中的代理选择原则：
1、当bean有实现的接口时，使用jdk动态代理！
2、当bean没有实现接口时，使用Cglib！
3、Spring可以通过配置强制使用Cglib，在容器xml中增加<aop:aspectj-autoproxy proxy-target-class="true"/>

jdk动态代理为啥必须要实现接口？
因为生成的代理类就是实现了接口，从而知道需要实现哪些需要被代理的方法！
而Cglib的生成代理类是继承，意味着子类拥有了父类所有的代码！


1.6门面模式和装饰器模式

门面模式（facade pattern）：又叫外观模式，提供了一个统一的接口，用来访问子系统中的一群接口！
特征：门面模式定义个一个高层接口，让子系统更容易使用！
属于结构型模式！

适用场景：
子系统越来越复杂，增加门面模式提供简单接口！
构建多层系统结构，利用门面对象作为每层的入口，简化层间调用！

1、门面模式与代理模式：
门面模式就是特殊的静态代理模式！区别在于，门面模式重点在于封装，静态代理重点在于增强！
所以可以理解为不做增强的静态代理就是门面模式！
（以后会有委派模式，也是一种静态代理！）
代理：结构型模式！
委派：行为型模式！不属于gof23

2、门面模式与单例模式
很多时候会把门面做成单例！例如Utils类！

门面优点：
1、简化调用过程，无需深入了解子系统，以防给子系统造成风险！
2、减少客户端依赖，松耦合！
3、更好划分层次，提高安全性！
4、遵循迪米特法则，最少知道原则！

门面缺点：
1、子系统扩展时，门面也需要修改，可能带来未知风险！
2、不符合开闭原则！
3、某些情况下违背单一职责原则！



装饰器模式（Decorator Pattern）：又叫包装模式（Wrapper Pattern），是指在不改变原有对象的基础上，将功能附加到原对象上，提供了比继承更有弹性的代替方案！（扩展原有对象的功能）
属于结构型模式！

运行期间进行功能“扩展”！（透明、动态的扩展！）

适用场景：
1、用于扩展一个类的功能或给一个类添加附加职责！
2、动态的给一个对象添加功能，这些功能可以再动态的撤销！


装饰器模式和代理模式对比：
1、装饰器模式就是一种特殊的代理模式（静态代理）！
2、装饰器模式强调自身的功能进行透明（用户自己看得到）、动态定制的扩展！
3、代理模式强调代理过程的控制！

装饰器模式优点：
1、装饰器是继承的有力补充，比继承更灵活，不改变原有对象的情况下动态的给一个对象扩展功能！
2、通过使用不同的装饰类以及这些装饰类的排列组合，可实现不同效果！
3、完全符合开闭原则！

缺点：类多，增加程序复杂性！



1.7享元模式和组合模式

享元模式（Flyweight Pattern）又称轻量级模式，是对象池的一种实现！
类似于线程池，线程池可以避免不停的创建和销毁多个对象，消耗性能！
提供了减少创建对象数量从而改善应用所需的对象结构的方式！

核心思想：共享细粒度对象，将对多个同一对象的访问集中起来！

属于结构型模式！

享元模式将一个对象的状态分成内部状态（不随环境改变）和外部状态，内部状态指不变的，外部状态是变化的！

适用场景：
常用于系统底层开发，以便解决系统性能问题！
系统有大量相似的对象，需要缓冲池的场景！

优点：
减少对象的创建，降低内存中的对象数量，降低系统的内存！
减少内存之外其他的资源占用！（如创建tcp连接数量！）

缺点：
使用时需关注内部、外部状态、线程安全！

享元模式中的享元工厂一般是和单例模式配合使用！比如连接池在整个应用只需要有一个！

组合模式（Composite Pattern）也称整体-部分模式，它的宗旨是通过将单个对象（叶子节点）和组合对象（树枝节点）用相同的接口进行表示！各节点具有相同的生命周期！

作用：是客户端对单个对象和组合对象保持一致的方式处理！

属于结构型模式！

适用场景：
1、希望客户端可以忽略组合对象和单个对象的差异时
2、对象层次具备整体和部分，呈树形结构（如树形菜单，操作系统目录结构，公司组织架构等）

优点：
1、清晰的定义分层地的复杂对象，表示对象的全部或部分层次
2、让客户端忽略了层次的差异，方面对整个层次结构进行控制
缺点：
1、限制类型时会较为复杂
2、使设计更加抽象

1.8 适配器模式和桥接模式
适配器模式（Adapter Pattern）又叫做变压器模式，他的功能是将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口匹配而导致无法在一起工作的两个类能一共使用！

属于结构型模式！

适用场景：
1、已经存在的类，它的方法和需求不匹配（方法结果相同或类似）的情况
2、适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同的产品，不同厂家造成功能类似而接口不同时的解决方案

优点：
1、提高类的透明性和复用性，现有的类复用单不需要改变
2、目标类和适配器类解耦，提高程序的扩展性
3、在很多业务场景中符合开闭原则



桥接模式（Bridge Pattern）也成为桥梁模式、接口模式（interface）或柄体模式（handler and body）模式，是将抽象部分与它的具体实现部分分离，使他们都可以独立的变化！

通过组合的方式建立两个类之间的关系，而不是通过继承！
很多情况下，桥接模式是多继承的代替方案！

属于结构型模式！

适用场景：
1、在抽象和具体实现之间需要增加更多的灵活性的场景！
2、一个类存在两个（或多个）独立变化的维度，而这两个（或多个）维度都需要进行独立的扩展！
3、不希望使用继承，或因为多层继承导致系统中类数量增加！

优点：
1、分离抽象部分和具体实现部分
2、提高了系统的扩展性
3、符合开闭原则
4、符合合成复用原则

缺点：
1、增加系统理解难度
2、需要正确识别系统中两个独立变化的维度

类似模式对比：
1、桥接模式和组合模式
2、桥接模式和适配器模式